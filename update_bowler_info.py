#!/usr/bin/env python3
"""
Bowler Info Update Script

This script helps update bowler information in the players table using CSV files
generated by analyze_bowler_data.py after manual data entry.

Usage:
    python update_bowler_info.py --csv missing_bowlers_20241207_123456.csv
    python update_bowler_info.py --csv incomplete_bowlers_20241207_123456.csv
    python update_bowler_info.py --single-update "Bowler Name"
"""

import argparse
import csv
import sys
from typing import Dict, List, Optional

from sqlalchemy.orm import sessionmaker
from database import get_database_connection
from models import Player


class BowlerInfoUpdater:
    """Updates bowler information in the players table."""
    
    def __init__(self):
        """Initialize database connection."""
        self.engine, SessionLocal = get_database_connection()
        self.session = SessionLocal()
        
    def __enter__(self):
        return self
        
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Clean up database connection."""
        self.session.close()
    
    def add_new_player(self, bowler_name: str, bowler_data: Dict) -> bool:
        """Add a new player to the players table."""
        try:
            # Check if player already exists
            existing_player = self.session.query(Player).filter(
                Player.name == bowler_name
            ).first()
            
            if existing_player:
                print(f"‚ö†Ô∏è  Player {bowler_name} already exists, skipping add...")
                return False
            
            # Create new player
            new_player = Player(
                name=bowler_name,
                bowler_type=bowler_data.get('bowler_type') or None,
                bowl_hand=bowler_data.get('bowl_hand') or None,
                bowl_type=bowler_data.get('bowl_type') or None,
                bowling_type=bowler_data.get('bowling_type') or None,
                nationality=bowler_data.get('nationality') or None
            )
            
            self.session.add(new_player)
            self.session.commit()
            
            print(f"‚úÖ Added new player: {bowler_name}")
            return True
            
        except Exception as e:
            print(f"‚ùå Error adding player {bowler_name}: {str(e)}")
            self.session.rollback()
            return False
    
    def update_existing_player(self, bowler_name: str, bowler_data: Dict) -> bool:
        """Update bowling information for existing player."""
        try:
            player = self.session.query(Player).filter(
                Player.name == bowler_name
            ).first()
            
            if not player:
                print(f"‚ùå Player {bowler_name} not found in database")
                return False
            
            # Track what we're updating
            updates = []
            
            # Update bowling information (only if new value provided)
            if bowler_data.get('new_bowler_type'):
                player.bowler_type = bowler_data['new_bowler_type']
                updates.append(f"bowler_type: {bowler_data['new_bowler_type']}")
                
            if bowler_data.get('new_bowl_hand'):
                player.bowl_hand = bowler_data['new_bowl_hand'] 
                updates.append(f"bowl_hand: {bowler_data['new_bowl_hand']}")
                
            if bowler_data.get('new_bowl_type'):
                player.bowl_type = bowler_data['new_bowl_type']
                updates.append(f"bowl_type: {bowler_data['new_bowl_type']}")
            
            # Also update legacy bowling_type if provided
            if bowler_data.get('bowling_type'):
                player.bowling_type = bowler_data['bowling_type']
                updates.append(f"bowling_type: {bowler_data['bowling_type']}")
            
            if updates:
                self.session.commit()
                print(f"‚úÖ Updated {bowler_name}: {', '.join(updates)}")
                return True
            else:
                print(f"‚ö†Ô∏è  No updates needed for {bowler_name}")
                return False
                
        except Exception as e:
            print(f"‚ùå Error updating player {bowler_name}: {str(e)}")
            self.session.rollback()
            return False
    
    def process_missing_bowlers_csv(self, csv_file: str) -> Dict[str, int]:
        """Process CSV file for missing bowlers (new additions)."""
        print(f"üìÑ Processing missing bowlers CSV: {csv_file}")
        
        results = {'added': 0, 'skipped': 0, 'errors': 0}
        
        try:
            with open(csv_file, 'r', encoding='utf-8') as file:
                reader = csv.DictReader(file)
                
                for row in reader:
                    bowler_name = row['bowler_name'].strip()
                    
                    # Skip if no bowler name
                    if not bowler_name:
                        continue
                    
                    # Skip if no bowling info provided (all fields empty)
                    bowling_fields = ['bowler_type', 'bowl_hand', 'bowl_type', 'bowling_type']
                    if not any(row.get(field, '').strip() for field in bowling_fields):
                        print(f"‚è≠Ô∏è  Skipping {bowler_name} - no bowling info provided")
                        results['skipped'] += 1
                        continue
                    
                    # Prepare data
                    bowler_data = {
                        'bowler_type': row.get('bowler_type', '').strip() or None,
                        'bowl_hand': row.get('bowl_hand', '').strip() or None,
                        'bowl_type': row.get('bowl_type', '').strip() or None,
                        'bowling_type': row.get('bowling_type', '').strip() or None,
                        'nationality': row.get('nationality', '').strip() or None
                    }
                    
                    # Add new player
                    if self.add_new_player(bowler_name, bowler_data):
                        results['added'] += 1
                    else:
                        results['errors'] += 1
        
        except FileNotFoundError:
            print(f"‚ùå CSV file not found: {csv_file}")
            return results
        except Exception as e:
            print(f"‚ùå Error processing CSV: {str(e)}")
            return results
        
        return results
    
    def process_incomplete_bowlers_csv(self, csv_file: str) -> Dict[str, int]:
        """Process CSV file for bowlers with incomplete information."""
        print(f"üìÑ Processing incomplete bowlers CSV: {csv_file}")
        
        results = {'updated': 0, 'skipped': 0, 'errors': 0}
        
        try:
            with open(csv_file, 'r', encoding='utf-8') as file:
                reader = csv.DictReader(file)
                
                for row in reader:
                    bowler_name = row['bowler_name'].strip()
                    
                    # Skip if no bowler name
                    if not bowler_name:
                        continue
                    
                    # Check if any new data provided
                    new_fields = ['new_bowler_type', 'new_bowl_hand', 'new_bowl_type']
                    if not any(row.get(field, '').strip() for field in new_fields):
                        print(f"‚è≠Ô∏è  Skipping {bowler_name} - no new info provided")
                        results['skipped'] += 1
                        continue
                    
                    # Prepare update data
                    bowler_data = {
                        'new_bowler_type': row.get('new_bowler_type', '').strip() or None,
                        'new_bowl_hand': row.get('new_bowl_hand', '').strip() or None,
                        'new_bowl_type': row.get('new_bowl_type', '').strip() or None,
                        'bowling_type': row.get('bowling_type', '').strip() or None
                    }
                    
                    # Update existing player
                    if self.update_existing_player(bowler_name, bowler_data):
                        results['updated'] += 1
                    else:
                        results['errors'] += 1
        
        except FileNotFoundError:
            print(f"‚ùå CSV file not found: {csv_file}")
            return results
        except Exception as e:
            print(f"‚ùå Error processing CSV: {str(e)}")
            return results
        
        return results
    
    def interactive_single_update(self, bowler_name: str):
        """Interactive update for a single bowler."""
        print(f"üîß Interactive update for: {bowler_name}")
        
        # Check if player exists
        player = self.session.query(Player).filter(Player.name == bowler_name).first()
        
        if not player:
            print(f"‚ùå Player {bowler_name} not found. Would you like to add them? (y/n)")
            if input().lower().strip() == 'y':
                return self._interactive_add_player(bowler_name)
            return
        
        # Show current info
        print(f"\nCurrent bowling info:")
        print(f"  ‚Ä¢ bowler_type: {player.bowler_type or 'None'}")
        print(f"  ‚Ä¢ bowl_hand: {player.bowl_hand or 'None'}")
        print(f"  ‚Ä¢ bowl_type: {player.bowl_type or 'None'}")
        print(f"  ‚Ä¢ bowling_type: {player.bowling_type or 'None'}")
        
        # Get updates
        updates = {}
        
        print(f"\nEnter new values (press Enter to keep current):")
        
        new_bowler_type = input(f"bowler_type [{player.bowler_type or ''}]: ").strip()
        if new_bowler_type:
            updates['new_bowler_type'] = new_bowler_type
            
        new_bowl_hand = input(f"bowl_hand [{player.bowl_hand or ''}]: ").strip()
        if new_bowl_hand:
            updates['new_bowl_hand'] = new_bowl_hand
            
        new_bowl_type = input(f"bowl_type [{player.bowl_type or ''}]: ").strip()
        if new_bowl_type:
            updates['new_bowl_type'] = new_bowl_type
        
        if updates:
            self.update_existing_player(bowler_name, updates)
        else:
            print("‚ö†Ô∏è  No changes made")
    
    def _interactive_add_player(self, bowler_name: str):
        """Interactive addition of new player."""
        print(f"‚ûï Adding new player: {bowler_name}")
        
        bowler_data = {}
        
        bowler_data['bowler_type'] = input("bowler_type: ").strip() or None
        bowler_data['bowl_hand'] = input("bowl_hand: ").strip() or None  
        bowler_data['bowl_type'] = input("bowl_type: ").strip() or None
        bowler_data['bowling_type'] = input("bowling_type (legacy): ").strip() or None
        bowler_data['nationality'] = input("nationality (optional): ").strip() or None
        
        self.add_new_player(bowler_name, bowler_data)


def main():
    """Main execution function."""
    parser = argparse.ArgumentParser(description='Update bowler information in players table')
    parser.add_argument('--csv', help='CSV file to process')
    parser.add_argument('--single-update', help='Single bowler name to update interactively')
    parser.add_argument('--dry-run', action='store_true', help='Preview changes without committing')
    
    args = parser.parse_args()
    
    if not args.csv and not args.single_update:
        print("‚ùå Please provide either --csv or --single-update option")
        parser.print_help()
        sys.exit(1)
    
    print("üèè Starting Bowler Info Update...")
    print("="*50)
    
    with BowlerInfoUpdater() as updater:
        if args.single_update:
            updater.interactive_single_update(args.single_update)
            
        elif args.csv:
            # Determine CSV type based on filename
            if 'missing_bowlers' in args.csv:
                results = updater.process_missing_bowlers_csv(args.csv)
                print(f"\nüìä Missing Bowlers Results:")
                print(f"   ‚Ä¢ Added: {results['added']}")
                print(f"   ‚Ä¢ Skipped: {results['skipped']}")
                print(f"   ‚Ä¢ Errors: {results['errors']}")
                
            elif 'incomplete_bowlers' in args.csv:
                results = updater.process_incomplete_bowlers_csv(args.csv)
                print(f"\nüìä Incomplete Bowlers Results:")
                print(f"   ‚Ä¢ Updated: {results['updated']}")
                print(f"   ‚Ä¢ Skipped: {results['skipped']}")
                print(f"   ‚Ä¢ Errors: {results['errors']}")
                
            else:
                print(f"‚ùå Cannot determine CSV type from filename: {args.csv}")
                print("   Expected: missing_bowlers_*.csv or incomplete_bowlers_*.csv")
    
    print("\n‚úÖ Update process completed!")


if __name__ == "__main__":
    main()
